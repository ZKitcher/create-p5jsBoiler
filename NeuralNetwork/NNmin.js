const rand=(a,b)=>void 0===a?Math.random():a instanceof Array?a[floor(rand(a.length))]:void 0===b?Math.random(1)*a:Math.random(1)*(b-a)+a,exp=a=>Math.exp(a),abs=a=>Math.abs(a),log=a=>Math.log(a),pow=(a,b)=>Math.pow(a,b),round=a=>Math.round(a),sqrt=a=>Math.sqrt(a),cosh=a=>(exp(a)+exp(-a))/2,floor=a=>Math.floor(a),cos=a=>Math.cos(a),sin=a=>Math.sin(a),max=(...a)=>Math.max(...a),min=(...a)=>Math.min(...a),PI=Math.PI,isNumber=a=>"number"==typeof a,between=(a,b,c)=>Math.min(Math.max(a,b),c),clog=(...a)=>console.log(...a),boxMuller=()=>Math.sqrt(-1*log(rand()))*cos(1*PI*rand()),distanceBetweenPoints=(a,b,c,d)=>sqrt(pow(c-a,2)+pow(d-b,2)),unitVector=(b,c,d,e,f,g)=>{let a=sqrt(pow(d-b,2)+pow(e-c,2));return{x:b+a/f*g/a*(d-b),y:c+a/f*g/a*(e-c)}};class Matrix{constructor(d=0,e=0,f=null){this.rows=d,this.cols=e;let b=[[]];for(let a=0;a<d;a++){b[a]=[];for(let c=0;c<e;c++)b[a][c]=0}this.matrix=f||b}print(){console.table(this.matrix)}static make(d=0,e=0){let b=[[]];for(let a=0;a<d;a++){b[a]=[];for(let c=0;c<e;c++)b[a][c]=0}return b}static add(d,e){let c=new Matrix(d.rows,d.cols);if(this.rows!==n.rows||this.cols!==n.cols){NetworkError.error("Matrix dimensions should match","Matrix.add");return}for(let a=0;a<c.rows;a++)for(let b=0;b<c.cols;b++)c.matrix[a][b]=d.matrix[a][b]+e.matrix[a][b];return c}add(a){if(a instanceof Matrix){if(this.rows!==a.rows||this.cols!==a.cols){NetworkError.error("Matrix dimensions should match",".add");return}for(let b=0;b<this.rows;b++)for(let c=0;c<this.cols;c++)this.matrix[b][c]+=a.matrix[b][c];return this}for(let d=0;d<this.rows;d++)for(let e=0;e<this.cols;e++)this.matrix[d][e]+=a;return this}addPercent(c){for(let a=0;a<this.rows;a++)for(let b=0;b<this.cols;b++){let d=this.matrix[a][b];this.matrix[a][b]+=d*c}}addRandom(e,c){let f=Matrix.make(this.rows,this.cols);if(c<=0||c>1)NetworkError.error("Probability argument must be between 0 and 1",".addRandom");else for(let a=0;a<this.rows;a++)for(let b=0;b<this.cols;b++){let d=this.matrix[a][b],g=rand(0,1);f[a][b]=g<c?d+d*rand(-e,e):d}this.set(f)}set(a){if("number"==typeof a.length&&"number"==typeof a[0].length&&"object"==typeof a){this.rows=a.length,this.cols=a[0].length;for(let b=0;b<this.rows;b++)this.matrix[b]=[...a[b]]}else{NetworkError.error("the argument of set(); must be an array within an array. Here is an example: [[1,0],[0,1]]",".set");return}}fillCol(b,c){if(b>=this.cols){NetworkError.error("The column index specified is too large for this matrix.",".fillCol");return}for(let a=0;a<this.rows;a++)this.matrix[a][b]=c;return this}fillRow(a,b){if(a>=this.rows){NetworkError.error("The row index specified is too large for this matrix.",".fillRow");return}return this.matrix[a].fill(b),this}static fromArray(b){let c=new Matrix(b.length,1);for(let a=0;a<b.length;a++)c.matrix[a][0]=b[a];return c}initiate(b=0){if(void 0!==b){if(isNumber(b)){for(let a=0;a<this.matrix.length;a++)for(let c=0;c<this.matrix[a].length;c++)this.matrix[a][c]=b;return this}NetworkError.error("The value entered as an argument is not a number",".initiate")}}insert(c,a,b){if(!isNumber(c)){NetworkError.error('Expected Number for "value" argument',".insert");return}if(!isNumber(a)){NetworkError.error('Expected Number for "x" argument',".insert");return}if(!isNumber(b)){NetworkError.error('Expected Number for "y" argument',".insert");return}if(a<this.rows&&b<this.cols)return this.matrix[a][b]=c,this;NetworkError.error("x, y arguments exceed the matrix dimensions.",".insert")}map(c){for(let a=0;a<this.rows;a++)for(let b=0;b<this.cols;b++){let d=this.matrix[a][b];this.matrix[a][b]=c(d)}return this}static map(a,d){if(a instanceof Matrix){for(let b=0;b<a.rows;b++)for(let c=0;c<a.cols;c++){let e=a.matrix[b][c];a.matrix[b][c]=d(e)}return a}NetworkError.error("First argument must be an instance of Matrix","Matrix.map")}mult(a){if(a instanceof Matrix){if(this.rows!==a.rows||this.cols!==a.cols){NetworkError.error("The matrix dimensions should match in order to multiply their values. If you are looking for dot product, try Matrix.mult",".mult");return}for(let b=0;b<this.rows;b++)for(let c=0;c<this.cols;c++)this.matrix[b][c]*=a.matrix[b][c];return this}for(let d=0;d<this.rows;d++)for(let e=0;e<this.cols;e++)this.matrix[d][e]*=a;return this}static mult(a,b){let c=new Matrix(a.rows,b.cols);if(a instanceof Matrix&&b instanceof Matrix){if(a.cols!==b.rows){NetworkError.error("The rows of B must match the columns of A","Matrix.mult");return}for(let d=0;d<c.rows;d++)for(let e=0;e<c.cols;e++){let g=0;for(let f=0;f<a.cols;f++)g+=a.matrix[d][f]*b.matrix[f][e];c.matrix[d][e]=g}return c}}randomize(c,d){for(let a=0;a<this.matrix.length;a++)for(let b=0;b<this.matrix[a].length;b++)this.matrix[a][b]=rand(c,d);return this}sub(a){if(a instanceof Matrix){if(this.rows!==a.rows||this.cols!==a.cols){NetworkError.error("Matrix dimensions should match",".sub");return}for(let b=0;b<this.rows;b++)for(let c=0;c<this.cols;c++)this.matrix[b][c]-=a.matrix[b][c];return this}for(let d=0;d<this.rows;d++)for(let e=0;e<this.cols;e++)this.matrix[d][e]-=a;return this}static sub(a,d){if(a instanceof Matrix&&d instanceof Matrix){if(a.rows!==d.rows||a.cols!==d.cols){NetworkError.error("The matrix dimensions should match","Matrix.sub");return}{let e=new Matrix(a.rows,a.cols);for(let b=0;b<e.rows;b++)for(let c=0;c<e.cols;c++)e.matrix[b][c]=a.matrix[b][c]-d.matrix[b][c];return e}}NetworkError.error("The arguments should be matrices","Matrix.sub")}static mean(a,d){if(a instanceof Matrix&&d instanceof Matrix){if(a.rows!==d.rows||a.cols!==d.cols){NetworkError.error("The matrix dimensions should match","Matrix.sub");return}{let e=new Matrix(a.rows,a.cols);for(let b=0;b<e.rows;b++)for(let c=0;c<e.cols;c++)e.matrix[b][c]=(a.matrix[b][c]+d.matrix[b][c])/2;return e}}NetworkError.error("The arguments should be matrices","Matrix.mean")}static merge(a,d){if(a instanceof Matrix&&d instanceof Matrix){if(a.rows!==d.rows||a.cols!==d.cols){NetworkError.error("The matrix dimensions should match","Matrix.sub");return}{let e=new Matrix(a.rows,a.cols);for(let b=0;b<e.rows;b++)for(let c=0;c<e.cols;c++){let f=rand(0,1);e.matrix[b][c]=f<.5?a.matrix[b][c]:d.matrix[b][c]}return e}}NetworkError.error("The arguments should be matrices","Matrix.mean")}toArray(){let b=[];if(1===this.cols){for(let a=0;a<this.rows;a++)b[a]=this.matrix[a][0];return b}return 1===this.rows?b=this.matrix[0]:void NetworkError.error("None of the lengths of the matrix equal 1",".toArray")}static toArray(a){let c=[];if(1===a.cols){for(let b=0;b<a.rows;b++)c[b]=a.matrix[b][0];return c}return 1===a.rows?c=a.matrix[0]:void NetworkError.error("None of the lengths of the matrix equal 1","Matrix.toArray")}static transpose(a){let d=new Matrix(a.cols,a.rows);for(let b=0;b<a.rows;b++)for(let c=0;c<a.cols;c++)d.matrix[c][b]=a.matrix[b][c];return d}static matchingDimentions(a,b){if(a instanceof Matrix&&b instanceof Matrix)return a.rows===b.rows&&a.cols===b.cols;NetworkError.error("The arguments should be matrices","Matrix.matchingDimentions")}log(a={table:!1,decimals:void 0}){let b=new Matrix(this.rows,this.cols);if(b.set(this.matrix),void 0!==a.decimals){let c=1e3;a.decimals>21?(NetworkError.warn("Maximum number of decimals is 21.","Matrix.log"),c=pow(10,21)):c=pow(10,a.decimals)||c,b.map(a=>round(a*c)/c)}a.table?console.table(b.matrix):console.log(b)}}const normaliseData=(a,b,c)=>((void 0===b|| void 0===c)&&(b=minValue(a),c=maxValue(a)),a.map(a=>(a-b)/(c-b))),maxValue=b=>{let c=0,d=b.length;for(let a=0;a<d;a++)b[a]>c&&(c=b[a]);return c},minValue=b=>{let c=1/0,d=b.length;for(let a=0;a<d;a++)b[a]<c&&(c=b[a]);return c},avg=a=>a.reduce((a,b)=>a+b,0)/a.length,smoothen=(b,d=.5)=>{for(var e=avg(b)*d,c=Array(b.length),a=0;a<b.length;a++){var f=a>0?c[a-1]:b[a],g=a<b.length?b[a]:b[a-1];c[a]=avg([e,avg([f,b[a],g])])}return c},lossfuncs={mae(e,b){let c=0,d=b.length;for(let a=0;a<d;a++){let f=b[a],g=e[a];c+=abs(f-g)}return c/d},bce(g,b){let c=0,d=b.length;for(let a=0;a<d;a++){let e=b[a],f=g[a];c+=e*log(f)+(1-e)*log(1-f)}return-c/d},lcl(e,b){let c=0,d=b.length;for(let a=0;a<d;a++){let f=b[a],g=e[a];c+=log(cosh(g-f))}return c/d},mbe(e,b){let c=0,d=b.length;for(let a=0;a<d;a++){let f=b[a],g=e[a];c+=f-g}return c/d},mael(f,c){let d=0,e=c.length;for(let a=0;a<e;a++){let g=c[a],h=f[a],b=g-h,i=-b*(exp(-b)-1),j=exp(-b)+1;d+=i/j}return d/e},rmse(e,b){let c=0,d=b.length;for(let a=0;a<d;a++){let f=b[a],g=e[a];c+=pow(f-g,2)}return sqrt(c/d)},mce(e,b){let c=0,d=b.length;for(let a=0;a<d;a++){let f=b[a],g=e[a];c+=pow(abs(f-g),3)}return c/d},mse(e,b){let c=0,d=b.length;for(let a=0;a<d;a++){let f=b[a],g=e[a];c+=pow(f-g,2)}return c/d},quantile(c,b,f){let e=f,d=0;for(let a=0;a<b.length;a++)b[a]-c[a]>=0?d+=e*(b[a]-c[a]):d+=(e-1)*(b[a]-c[a]);return d/b.length}},activations={sigmoid:a=>1/(1+exp(-a)),sigmoid_d(b){let a=1/(1+exp(-b));return a*(1-a)},silu:a=>a/(1+exp(-a)),silu_d(a){let b=1+exp(-a)+a*exp(-a),c=pow(1+exp(-a),2);return b/c},tanh(a){let b=exp(a)-exp(-a),c=exp(a)+exp(-a);return b/c},tanh_d(a){let b=pow(exp(2*a)-1,2),c=pow(exp(2*a)+1,2);return 1-b/c},leakyrelu:a=>max(a,.01*a),leakyrelu_d:a=>a>=0?1:.01,relu:a=>max(a,0),relu_d:a=>a>=0?1:0,sinc:a=>0===a?1:sin(a)/a,sinc_d:a=>0===a?0:cos(a)/a-sin(a)/(a*a),softsign:a=>a/(1+abs(a)),softsign_d(b){let a=1+abs(b);return 1/(a*a)},binary:a=>a<=0?0:1,binary_d:a=>0,softplus:a=>log(1+exp(a)),softplus_d:a=>1/(1+exp(-a)),leakyrelucapped:a=>a>=0&&a<=6?a:a<0?.1*a:6,leakyrelucapped_d:a=>a>=0&&a<=6?1:a<0?.1:0,leakysigmoid:a=>1/(1+exp(-a))+a/100,leakysigmoid_d:a=>exp(-a)/pow(exp(-a)+1,2)+.01,gaussian:a=>pow(Math.E,-pow(a,2)),gaussian_d:a=>-2*a*pow(Math.E,-pow(a,2))};(NetworkError=function(a,b){this.msg=a,this.method=b}).prototype.warn=()=>{console.warn("Warning: "+this.message),console.warn("> "+this.method),console.trace()},NetworkError.prototype.error=()=>{console.error("Error: "+this.message),console.error("> "+this.method),console.trace()},NetworkError.warn=(a,b)=>{console.warn("Warning: "+a),console.warn("> "+b),console.trace()},NetworkError.error=(a,b)=>{console.error("Error: "+a),console.error("> "+b),console.trace()};const LayerType={input:"input",hidden:"hidden",output:"output"},actFunc={sigmoid:"sigmoid",silu:"silu",tanh:"tanh",leakyrelu:"leakyrelu",relu:"relu",sinc:"sinc",softsign:"softsign",binary:"binary",softplus:"softplus",leakyrelucapped:"leakyrelucapped",leakysigmoid:"leakysigmoid",gaussian:"gaussian"},lossFunctions={MeanSquareError:lossfuncs.mse,MeanAbsoluteError:lossfuncs.mae,MeanBiasError:lossfuncs.mbe,BinaryCrossEntropy:lossfuncs.bce,MinimumClassificationError:lossfuncs.mce,RootMeanSquareError:lossfuncs.rmse,MeanAbsoluteExponential:lossfuncs.mael,LogCoshLoss:lossfuncs.lcl,Quantile:lossfuncs.quantile},translateLossFunc=a=>{switch(a){case"mse":return"Mean Square Error";case"mae":return"Mean Absolute Error";case"mbe":return"Mean Bias Error";case"bce":return"Binary Cross Entropy";case"mce":return"Minimum Classification Error";case"rmse":return"Root Mean Square Error";case"mael":return"Mean Absolute Exponential";case"lcl":return"Log Cosh Loss";case"quantile":return"Quantile"}};class Layer{constructor(b,a,c){this.type=b,this.type===LayerType.hidden||this.type===LayerType.output?(this.size=a,this.setActivation(c),this.layer=new Matrix(this.size,1)):this.type===LayerType.input?(this.size=a,this.layer=new Matrix(this.size,1)):"string"==typeof this.type?NetworkError.error(`The Layer type '${this.type}' is not valid.`,"Layer.constructor"):NetworkError.error("You need to specify a valid type of Layer","Layer.constructor")}setActivation(b){let a=Layer.stringTofunc(b);if(void 0!==a)this.actname=a.name,this.actname_d=a.name_d,this.actfunc=a.func,this.actfunc_d=a.func_d;else{NetworkError.error("Bad activation information","Layer.setActivation");return}}feed(c,a){let d=!1,e=!1,f=this.sampleSize,g=this.stride;if(void 0!==a&&(a.log&&(d=a.log),a.table&&(e=a.table)),c.length!==this.inputSize){NetworkError.error(`The data you are trying to feed to this ${this.type} layer is not the same length as the number of input this layer has.`,"Layer.feed");return}{let b=this.downsample(c,f,g);return d&&(e?console.table(b):clog(b)),b}}print(){clog(this)}getSqIndex(a,b,c){return a*c+b}getPrefix(){let a=this.type,b=a.length,c=a.slice(0,b-4);return c}static stringTofunc(a){let b=a.toLocaleLowerCase(),c=`${b}_d`,d=activations[b],e=activations[c];if(void 0!==d)return void 0!==e?{name:b,name_d:c,func:d,func_d:e}:void NetworkError.error(`You need to create the derivative of your custom function. The activation function specified '${a}' does not have a derivative assigned. The activation function was set to the default 'sigmoid'.`,"Layer.stringTofunc");NetworkError.error(`The activation function '${a}' is not a valid activation function. The activation function was set to the default 'sigmoid'.`,"Layer.stringTofunc")}}class NeuralNetwork{constructor(a=1,b=1){this.i=a,this.o=b,this.inputs=new Layer(LayerType.input,a),this.outputs=new Layer(LayerType.output,b,actFunc.sigmoid),this.Layers=[this.inputs,this.outputs],this.weights=[],this.biases=[],this.errors=[],this.gradients=[],this.dropout=[],this.outs=[],this.loss=0,this.learningRate=.1,this.architecture=[a,b],this.epoch=0,this.timeTraining=0,this.correctPrediction=0,this.predictionCount=0,this.accuracyThreshold=.1,this.lossfunc=lossFunctions.MeanSquareError,this.lossfuncName=translateLossFunc(this.lossfunc.name),this.percentile=.5}asLabel(a){return a.indexOf(Math.max(...a))}checkArrayLength(a,b){return a.length===b}addHiddenLayer(b,a){void 0!==a?void 0===activations[a.toLocaleLowerCase()]&&("string"==typeof a&&NetworkError.error(`'${a}' is not a valid activation function, as a result, the activation function was set to 'sigmoid'.`,"NeuralNetwork.addHiddenLayer"),a=actFunc.sigmoid):a=actFunc.sigmoid,this.architecture.splice(this.architecture.length-1,0,b);let c=new Layer(LayerType.hidden,b,a);this.Layers.splice(this.Layers.length-1,0,c)}makeWeights(d,e){let f=-1,g=1;void 0!==d&& void 0!==e&&(f=d,g=e);for(let a=0;a<this.Layers.length-1;a++){let h=this.Layers[a],b=this.Layers[a+1],i=new Matrix(b.layer.rows,h.layer.rows),j=new Matrix(b.layer.rows,1);this.errors[a]=new Matrix(b.layer.rows,1),this.gradients[a]=new Matrix(b.layer.rows,1),this.weights[a]=i.randomize(f,g),this.biases[a]=j.randomize(1,-1),void 0===b.actfunc&&b.setActivation(actFunc.sigmoid)}for(let c=0;c<this.Layers.length;c++)this.architecture[c]=this.Layers[c].layer.rows}outputActivation(a){let b=a.toLocaleLowerCase();if(void 0===activations[b]){if("string"==typeof a){NetworkError.error(`'${a}' is not a valid activation function, as a result, the activation function is set to 'sigmoid' by default.`,"NeuralNetwork.outputActivation");return}NetworkError.error("Did not detect a string value, as a result, the activation function is set to 'sigmoid' by default.","NeuralNetwork.outputActivation");return}this.Layers[this.Layers.length-1].setActivation(a)}ffwDefaults(){return{log:!1,table:!1,decimals:void 0,asLabel:!1}}feedForward(e,a=this.ffwDefaults()){let f=void 0!==a.decimals,h=pow(10,a.decimals)||1e3;if(this.checkArrayLength(e,this.i))this.Layers[0].layer=Matrix.fromArray(e);else{NetworkError.error("The input array length does not match the number of inputs the js model has.","NeuralNetwork.feedForward");return}this.checkArrayLength(this.weights,0)&&(NetworkError.warn("The weights were not initiated. Please use the .makeWeights(); function after the initialization of the layers.","NeuralNetwork.feedForward"),this.makeWeights());for(let b=0;b<this.weights.length;b++){let g=this.Layers[b],d=this.Layers[b+1];d.layer=Matrix.mult(this.weights[b],g.layer),d.layer.add(this.biases[b]),d.layer.map(d.actfunc)}this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer);let c=this.outs;return f&&a.asLabel?NetworkError.warn("Cannot round if output is a label","NeuralNetwork.feedForward"):a.asLabel?c=this.asLabel(c):f&&!a.asLabel&&(c=c.map(a=>round(a*h)/h)),a.log&&clog("Prediction: ",c),c}predict(){return this.feedForward.apply(this,arguments)}feed(a){clog("Inputs: ",a),this.feedForward(a,{log:!0,decimals:3}),this.print("---------------------------")}exhibition(a){a.forEach(a=>{if(!a.input){NetworkError.error("Dataset missing (.input) property.","NeuralNetwork.exhibition");return}clog("\u{1F522} Inputs:			",JSON.stringify(a.input));let b=this.feedForward(a.input,{log:!1,decimals:3});if(a.target){let c=this.isCorrect(a.target,b);clog("\u{1F3AF} Target:			",JSON.stringify(a.target)),clog("%c\u{1F52E} Prediction:",`background-color: ${c?"#bcffa8":"#ffa8a8"};`,"	",JSON.stringify(b),`${c?"\u2714\uFE0F":"\u274C"}`)}else clog(`🔮 Prediction:		`,JSON.stringify(b));clog("---------------------------")})}bckDefaults(){return{log:!1,mode:"cpu",table:!1,dropout:void 0}}backpropagate(g,c,b=this.bckDefaults()){let f;if(this.checkArrayLength(c,this.o))f=Matrix.fromArray(c);else{NetworkError.error("The target array length does not match the number of ouputs the model has.","NeuralNetwork.backpropagate");return}if(!this.checkLearningRate())return;if(void 0!==b.dropout){if(!this.checkDropoutRate(b.dropout))return;this.addDropout(b.dropout)}this.outs=this.feedForward(g,{log:!1,mode:b.mode}),this.predictionCount++,this.correctPrediction+=this.isCorrect(c,this.outs)?1:0,this.errors[this.errors.length-1]=Matrix.sub(f,this.Layers[this.Layers.length-1].layer),this.gradients[this.gradients.length-1]=Matrix.map(this.Layers[this.Layers.length-1].layer,this.Layers[this.Layers.length-1].actfunc_d).mult(this.errors[this.errors.length-1]).mult(this.learningRate);for(let a=this.weights.length-1;a>0;a--){let d=Matrix.mult(this.gradients[a],Matrix.transpose(this.Layers[a].layer));void 0!==b.dropout&&(d=d.mult(this.dropout[a])),this.weights[a].add(d),this.biases[a].add(this.gradients[a]);let h=Matrix.transpose(this.weights[a]);this.errors[a-1]=Matrix.mult(h,this.errors[a]),this.gradients[a-1]=Matrix.map(this.Layers[a].layer,this.Layers[a].actfunc_d).mult(this.errors[a-1]).mult(this.learningRate)}let i=Matrix.transpose(this.Layers[0].layer),e=Matrix.mult(this.gradients[0],i);void 0!==b.dropout&&(e=e.mult(this.dropout[0])),this.weights[0].add(e),this.biases[0].add(this.gradients[0]),this.loss=this.lossfunc(this.outs,c,this.percentile),!0===b.log&&(this.print("Prediction: "),this.print(this.outs,b.table),this.print("target: "),this.print(c,b.table),this.print(`Loss: ${this.loss}`))}isCorrect(a,b){return a.filter((a,c)=>abs(a-b[c])<=this.accuracyThreshold).length===a.length}train(a,b,d){b.forEach(a=>{if(!a.input){NetworkError.error("Dataset missing (.input) property.","NeuralNetwork.train");return}a.target}),a+=this.epoch;let c=performance.now();for(this.epoch;this.epoch<a;this.epoch++)b.forEach(a=>this.backpropagate(a.input,a.target,d));this.timeTraining+=performance.now()-c}mapWeights(b){if("function"==typeof b)for(let a=0;a<this.weights.length;a++)this.weights[a].map(b);else NetworkError.error("Argument must be a function","NeuralNetwork.mapWeights")}logDefaults(){return{struct:!0,misc:!0,weights:!1,biases:!1,gradients:!1,errors:!1,layers:!1,table:!1,decimals:3,details:!1}}log(a=this.logDefaults()){let c=1e3;if(a.decimals>21?(NetworkError.error("Maximum number of decimals is 21.","NeuralNetwork.log"),c=pow(10,21)):c=pow(10,a.decimals)||c,a.details){let b=a.details;a.gradients=b,a.weights=b,a.errors=b,a.biases=b,a.struct=b,a.misc=b,a.layers=b}0===this.weights.length&&this.makeWeights(),a.struct&&(clog("%c\u{1F9E0} Network:","padding: 0.2em; font-size: 2em;"),clog("Layers:"),this.Layers.forEach((c,b)=>{clog(`	${0===b?"Input Layer:":b===this.Layers.length-1?"Output Layer:":"Hidden Layer:"}	${c.size}	${b?`(${c.actname})`:""}`),a.layers&&clog(this.Layers[b])})),a.weights&&(clog("Weights:"),this.weights.forEach(b=>b.log({decimals:a.decimals,table:a.table}))),a.biases&&(clog("Biases:"),this.biases.forEach(b=>b.log({decimals:a.decimals,table:a.table}))),a.errors&&(clog("Errors:"),this.errors.forEach(b=>b.log({decimals:a.decimals,table:a.table}))),a.gradients&&(clog("Gradients:"),this.gradients.forEach(b=>b.log({decimals:a.decimals,table:a.table}))),a.misc&&(clog("Other Values: "),clog(`	Learning Rate:	${this.learningRate}`),clog(`	Loss Function:	${this.lossfuncName}`),clog(`	Current Epoch:	${this.epoch.toLocaleString()}`),clog(`	Accuracy:		${(this.correctPrediction/this.predictionCount*100).toFixed(2)}%`),clog(`	Time Training:	${this.timeTraining.toFixed(2)}/ms	~${(this.timeTraining/this.epoch).toFixed(5)}/ms Per Epoch`),clog(`	Latest Loss:	${this.loss}`),this.print("---------------------------")),clog("\n")}print(a,b=!1){b?console.table(a):clog(a)}checkLearningRate(){return isNumber(this.learningRate)?!(this.learningRate>=1)||(NetworkError.error("The learning rate specified is greater or equal to 1","NeuralNetwork.backpropagate"),!1):(NetworkError.error("The learning rate specified (.learningRate property) is not a number.","NeuralNetwork.backpropagate"),!1)}checkDropoutRate(a){return a>=1?(NetworkError.error("The probability value can not be bigger or equal to 1","NeuralNetwork.backpropagate"),!1):!(a<=0)||(NetworkError.error("The probability value can not be smaller or equal to 0","NeuralNetwork.backpropagate"),!1)}addDropout(rate){if(0===this.weights.length){NetworkError.error("You need to initialise weights before using this function, use NetworkError.makeWeights();","NetworkError.addDropout");return}let func=(a=>Math.floor(Math.random()+(1-rate))).toString().replace(/rate/gm,rate),randomMap=eval(func),inactive=[];for(let i=0;i<this.Layers.length;i++){let neuronList=new Array(this.Layers[i].size).fill(1).map(randomMap);inactive.push(neuronList)}this.dropout=[];for(let i=0;i<this.weights.length;i++)this.dropout.push(new Matrix(this.weights[i].rows,this.weights[i].cols).initiate(1));for(let i=0;i<inactive.length;i++)if(0===i)for(let j=0;j<inactive[i].length;j++)0===inactive[i][j]&&this.dropout[i].fillCol(j,0);else if(i===inactive.length-1)for(let j=0;j<inactive[i].length;j++)0===inactive[i][j]&&this.dropout[i-1].fillRow(j,0);else for(let j=0;j<inactive[i].length;j++)0===inactive[i][j]&&(this.dropout[i-1].fillRow(j,0),this.dropout[i].fillCol(j,0))}fromJSON(a){return this.i=a.architecture[0],this.o=a.architecture[a.architecture.length-1],this.inputs=new Matrix(this.i,1),this.outputs=new Matrix(this.o,1),a.layers.map((a,b)=>this.Layers[b]=new Layer(a.type,a.size,a.actname)),this.makeWeights(),a.weights.map((a,b)=>this.weights[b].set(a)),a.biases.map((a,b)=>this.biases[b].set(a)),a.errors.map((a,b)=>this.errors[b].set(a)),a.gradients.map((a,b)=>this.gradients[b].set(a)),this.lossfunc=lossfuncs[a.lossFunction],this.lossfuncName=a.lossFunctionName,this.outs=Matrix.toArray(this.Layers[this.Layers.length-1].layer),this.loss=a.latestLoss,this.learningRate=a.learningRate,this.architecture=a.architecture,this.epoch=a.epoch,this.percentile=a.percentile,this.timeTraining=a.timeTraining,this.correctPrediction=a.correctPrediction,this.predictionCount=a.predictionCount,this.accuracyThreshold=a.accuracyThreshold,this}toJSON(){return{architecture:this.architecture,epoch:this.epoch,learningRate:this.learningRate,lossFunction:this.lossfunc.name,lossFunctionName:this.lossfuncName,latestLoss:this.loss,percentile:this.percentile,timeTraining:this.timeTraining,correctPrediction:this.correctPrediction,predictionCount:this.predictionCount,accuracyThreshold:this.accuracyThreshold,layers:this.Layers.map(a=>a),weights:this.weights.map(a=>a.matrix),biases:this.biases.map(a=>a.matrix),gradients:this.gradients.map(a=>a.matrix),errors:this.errors.map(a=>a.matrix)}}static createFromJSON(a){"string"==typeof a&&(a=JSON.parse(a));let b=new NeuralNetwork;return b.fromJSON(a),b}downloadNetwork(a="Neural Network"){download(a,JSON.stringify(this.toJSON()))}copy(){return NeuralNetwork.createFromJSON(this.toJSON())}mutateAdd(b){if("number"!=typeof b){NetworkError.error("randomFactor argument must be a number.","NeuralNetwork.mutateAdd");return}for(let a=0;a<this.weights.length;a++)this.weights[a].addPercent(b)}mutateRandom(c,a){if("number"!=typeof c){NetworkError.error("Range argument must be a number.","NeuralNetwork.mutateRandom");return}if(void 0!==a){if("number"!=typeof a){NetworkError.error("Probability argument must be a number.","NeuralNetwork.mutateRandom");return}}else a=1;for(let b=0;b<this.weights.length;b++)this.weights[b].addRandom(c,a)}static mergeNetworks(d,e){if(!(d instanceof NeuralNetwork||e instanceof NeuralNetwork)){NetworkError.error("Inputs must be Neural networrk objects.","NeuralNetwork.mergeNetworks");return}let a=d.copy();for(let b=0;b<a.weights.length;b++)a.weights[b]=Matrix.merge(d.weights[b],e.weights[b]);for(let c=0;c<a.biases.length;c++)a.biases[c]=Matrix.merge(d.biases[c],e.biases[c]);return a}}class NEATConnection{constructor(a,b,c){this.fromNode=a,this.toNode=b,this.weight=c,this.enabled=!0}mutateWeight(a){.05>rand()?this.weight=rand(-1,1):this.weight+=rand(-a,a)}copy(){let a=new NEATConnection(this.fromNode,this.toNode,this.weight);return a.enabled=this.enabled,a}getInnovationNumber(){let a=this.fromNode.number+this.toNode.number;return .5*a* ++a+this.toNode.number}}class NEATNode{constructor(a,b,c){this.number=a,this.layer=b,this.bias=rand(-1,1),this.output=c||!1,this.activation=actFunc[rand(Object.keys(actFunc))],this.inputSum=0,this.outputValue=0,this.outputConnections=[],this.id=rand()}engage(){0!==this.layer&&(this.outputValue=activations[this.activation](this.inputSum+this.bias));for(let a=0;a<this.outputConnections.length;a++)this.outputConnections[a].enabled&&(this.outputConnections[a].toNode.inputSum+=this.outputConnections[a].weight*this.outputValue)}mutateBias(a){.05>rand()?this.bias=rand(-1,1):this.bias+=rand(-a,a)}mutateActivation(a){void 0===a?this.activation=actFunc[rand(Object.keys(actFunc))]:void 0!==actFunc[a]?this.activation=a:(NetworkError.warn(`Provided Activation function "${a}" not listed, assigning random`,"NEATNode.mutateActivation"),this.activation=actFunc[rand(Object.keys(actFunc))])}copy(){let a=new NEATNode(this.number,this.layer,this.output);return a.bias=this.bias,a.activation=this.activation,a}}class NEATGenome{constructor(e=1,f=1,g=rand(),h=!1){if(this.inputs=e,this.outputs=f,this.id=g,this.layers=2,this.nextNode=0,this.nodes=[],this.connections=[],this.mutationRates={},this.rollMutations(),!h){for(let c=0;c<this.inputs;c++)this.nodes.push(new NEATNode(this.nextNode,0)),this.nextNode++;for(let d=0;d<this.outputs;d++){let i=new NEATNode(this.nextNode,1,!0);this.nodes.push(i),this.nextNode++}for(let a=0;a<this.inputs;a++)for(let b=this.inputs;b<this.outputs+this.inputs;b++)this.connections.push(new NEATConnection(this.nodes[a],this.nodes[b],rand(-1,1)))}this.generateNetwork()}generateNetwork(){for(let b=0;b<this.nodes.length;b++)this.nodes[b].outputConnections=[];for(let a=0;a<this.connections.length;a++)this.connections[a].fromNode.outputConnections.push(this.connections[a]);this.sortByLayer()}predict(a){return this.feedForward(a)}feedForward(d){let b=[],c=0;for(let a=0;a<this.nodes.length;a++)a<this.inputs&&(this.nodes[a].outputValue=d[a]),this.nodes[a].engage(),this.nodes[a].output&&(b[c]=this.nodes[a].outputValue,c++),this.nodes[a].inputSum=0;return b}crossover(c){let a=new NEATGenome(this.inputs,this.outputs,rand(),!0);for(let h=0;h<this.nodes.length;h++){let d=this.nodes[h].copy();if(d.output){let i=c.nodes[c.getNode(d.number)];rand()>.5&&(d.activation=i.activation,d.bias=i.bias)}a.nodes[h]=d}for(let e=0;e<this.connections.length;e++){let j=this.commonConnection(this.connections[e].getInnovationNumber(),c.connections),b=-1!==j?rand()>.5?this.connections[e].copy():c.connections[j].copy():this.connections[e].copy();b.fromNode=a.nodes[a.getNode(b.fromNode.number)],b.toNode=a.nodes[a.getNode(b.toNode.number)],b.fromNode&&b.toNode&&a.connections.push(b)}let f=this.mutationRates,g=c.mutationRates;return a.mutationRates.connectionRate=rand()>.5?f.connectionRate:g.connectionRate,a.mutationRates.biasRate=rand()>.5?f.biasRate:g.biasRate,a.mutationRates.activationRate=rand()>.5?f.activationRate:g.activationRate,a.mutationRates.addConnectionRate=rand()>.5?f.addConnectionRate:g.addConnectionRate,a.mutationRates.addNodeRate=rand()>.5?f.addNodeRate:g.addNodeRate,a.layers=this.layers,a.nextNode=a.nodes.length,a}mutate(b=.1){let a=this.mutationRates;this.connections.forEach(c=>{rand()<a.connectionRate&&c.mutateWeight(b)}),this.nodes.forEach(c=>{rand()<a.biasRate&&c.mutateBias(b)}),rand()<a.activationRate&&this.nodes[floor(rand(this.nodes.length))].mutateActivation(),rand()<a.addConnectionRate&&this.addConnection(),rand()<a.addNodeRate&&this.addNode(),rand()<a.rollMutation&&this.rollMutations(),this.generateNetwork()}rollMutations(){this.mutationRates.rollMutation=rand(.01,1),this.mutationRates.connectionRate=rand(.8,.9),this.mutationRates.biasRate=rand(.5,.6),this.mutationRates.activationRate=rand(.05,.1),this.mutationRates.addConnectionRate=rand(.05,.1),this.mutationRates.addNodeRate=rand(.01,.05)}addNode(){let b=floor(rand(this.connections.length)),a=this.connections[b];0===a.fromNode.layer||a.toNode.output||(b=floor(rand(this.connections.length)),a=this.connections[b]),a.enabled=!1,this.connections.splice(b,1);let d=new NEATNode(this.nextNode,a.fromNode.layer+1);for(let c=0;c<this.nodes.length;c++)this.nodes[c].layer>a.fromNode.layer&&this.nodes[c].layer++;let e=new NEATConnection(a.fromNode,d,1),f=new NEATConnection(d,a.toNode,a.weight);this.layers++,this.connections.push(e),this.connections.push(f),this.nodes.push(d),this.nextNode++}addConnection(){if(this.fullyConnected())return;let a=floor(rand(this.nodes.length)),b=floor(rand(this.nodes.length));for(;this.nodes[a].layer===this.nodes[b].layer||this.nodesConnected(this.nodes[a],this.nodes[b]);)a=floor(rand(this.nodes.length)),b=floor(rand(this.nodes.length));if(this.nodes[a].layer>this.nodes[b].layer){let c=a;a=b,b=c}let d=new NEATConnection(this.nodes[a],this.nodes[b],rand(-1,1));this.connections.push(d)}commonConnection(b,a){return a.findIndex(a=>b===a.getInnovationNumber())}nodesConnected(c,d){for(let b=0;b<this.connections.length;b++){let a=this.connections[b];if(a.fromNode==c&&a.toNode==d||a.fromNode==d&&a.toNode==c)return!0}return!1}fullyConnected(){let e=0,a=[];for(let b=0;b<this.nodes.length;b++)void 0!==a[this.nodes[b].layer]?a[this.nodes[b].layer]++:a[this.nodes[b].layer]=1;for(let c=0;c<this.layers-1;c++)for(let d=c+1;d<this.layers;d++)e+=a[c]*a[d];return e===this.connections.length}sortByLayer(){this.nodes.sort((a,b)=>a.layer-b.layer)}getNode(a){return this.nodes.findIndex(b=>b.number===a)}toJSON(){return{inputs:this.inputs,outputs:this.outputs,id:this.id,layers:this.layers,nextNode:this.nextNode,mutationRates:this.mutationRates,nodes:this.nodes.map(a=>({activation:a.activation,bias:a.bias,id:a.id,inputSum:a.inputSum,layer:a.layer,number:a.number,output:a.output,outputConnections:[],outputValue:a.outputValue})),connections:this.connections.map(a=>({enabled:a.enabled,fromNode:a.fromNode.id,toNode:a.toNode.id,weight:a.weight}))}}fromJSON(a){this.inputs=a.inputs,this.outputs=a.outputs,this.id=a.id,this.layers=a.layers,this.nextNode=a.nextNode,this.mutationRates=a.mutationRates,this.nodes=a.nodes.map(b=>{let a=new NEATNode;return a.activation=b.activation,a.bias=b.bias,a.id=b.id,a.inputSum=b.inputSum,a.layer=b.layer,a.number=b.number,a.output=b.output,a.outputConnections=b.outputConnections,a.outputValue=b.outputValue,a}),this.connections=a.connections.map(b=>{let a=new NEATConnection;return a.enabled=b.enabled,a.weight=b.weight,a.fromNode=this.nodes.find(a=>a.id===b.fromNode),a.toNode=this.nodes.find(a=>a.id===b.toNode),a}),this.generateNetwork()}downloadNetwork(a="NEAT Genome"){download(a,JSON.stringify(this.toJSON()))}copy(){let a=new NEATGenome(this.inputs,this.outputs,this.id);return a.mutationRates=this.mutationRates,a.nodes=this.nodes.slice(),a.connections=this.connections.slice(),a}static createFromJSON(a){"string"==typeof a&&(a=JSON.parse(a));let b=new NEATGenome;return b.fromJSON(a),b}render(e=500,f=400,c="svgBrainContainer"){let k=document.getElementById(c);if(!k){let a=document.createElement("div");a.id=c,a.style.position="absolute",a.style.top="5px",a.style.right="5px",document.body.prepend(a)}let b=document.getElementById(agent.id);b&&b.parentNode.removeChild(b);let g=d3.select("body").append("svg").attr("width",e).attr("height",f).attr("id",agent.id),d=d3.layout.force().size([e,f]),l=1/0,m=-1/0,h=agent.connections.map(a=>(a.weight>m&&(m=a.weight),a.weight<l&&(l=a.weight),{source:agent.getNode(a.fromNode.number),target:agent.getNode(a.toNode.number),weight:a.weight,enabled:a.enabled})),i=agent.nodes.map(b=>{let a=b.copy();return 0===a.layer?(a.fixed=!0,a.y=f-.2*f,a.x=e/agent.inputs*a.number+e/agent.inputs/2):a.output&&(a.fixed=!0,a.y=.2*f,a.x=e/agent.outputs*(a.number-agent.inputs)+e/agent.outputs/2),a}),n=(b,a,c)=>`hsl(${((1-(b-a)/(c-a))*120).toString(10)},100%,50%)`;d.nodes(i).links(h).gravity(.001).linkStrength(1).start();let o=g.selectAll(".link").data(h).enter().append("line").attr("class","link").style("stroke-width",a=>a.enabled?abs(a.weight)+1:0).style("stroke",a=>n(a.weight,l,m)).style("opacity",a=>0===a.source.layer&&a.target.output?"0.5":"1"),j=g.selectAll(".node").data(i).enter().append("g").attr("class","node").call(d.drag);j.append("circle").attr("r","5").attr("fill",a=>0==a.layer?"#00f":a.output?"#f00":"#000"),j.append("text").attr("dx",10).attr("dy",4).text(a=>a.output?`(${a.activation})`:null),d.on("tick",()=>{o.attr("x1",a=>a.source.x).attr("y1",a=>a.source.y).attr("x2",a=>a.target.x).attr("y2",a=>a.target.y),j.attr("transform",a=>`translate(${a.x},${a.y})`)}),b=document.getElementById(agent.id),document.getElementById(c).append(b)}}const download=(b,c)=>{let d="data:text/json;charset=utf-8,"+encodeURIComponent(c),a=document.createElement("a");a.setAttribute("href",d),a.setAttribute("download",b+".json"),document.body.appendChild(a),a.click(),a.remove()},XORDemo=()=>{let b=[{input:[0,0],target:[0]},{input:[1,1],target:[0]},{input:[0,1],target:[1]},{input:[1,0],target:[1]}];clog("%cXOR Gate Demo","font-size: 2em; font-weight: bold;");let a=new NeuralNetwork(2,1);a.addHiddenLayer(6,actFunc.tanh),a.outputActivation(actFunc.sigmoid),a.makeWeights(),clog("%c\u{1F4C9} Before Training","padding: 0.2em; font-size: 1.5em; background: #FF6E6E;"),a.exhibition(b),a.train(5e3,b),clog("%c\u{1F4C8} After Training","padding: 0.2em; font-size: 1.5em; background: #3BFF72;"),a.exhibition(b),a.log()};if(!document.getElementById("d3js")){let D3JS="https://d3js.org/d3.v2.min.js",script=document.createElement("script");script.id="d3js",script.setAttribute("src",D3JS),document.head.appendChild(script)}class NEATPopulation{constructor(a,b=50){this.popSize=b,this.agents=[],this.matingPool=[],this.datacollection=[],this.generation=1,this.constructor=a,this.mutationRate=.1,this.averageFitness=0,this.timerEnabled=!0,this.timerCount=30,this.timer=this.timerCount,this.pause=!1,this.topAgent=null,this.topFitness=0,this.eliteAgents=5,this.showBrain=!0,this.TopAgentsView=!1,this.error=!1,this.styling={fontColour:null},this.generateAgentsPool(),"undefined"==typeof completedGeneration&&NetworkError.warn("completedGeneration(topAgent) not set to fire after each generation.","NEATPopulation.constructor")}generateAgentsPool(){for(let a=0;a<this.popSize;a++){let b=this.buildAgent(a);if(!1===b)return b;this.agents.push(b),this.agents[a].brain.generateNetwork(),this.agents[a].brain.mutate()}}buildAgent(...b){let a=new this.constructor(...b);return void 0===a.calculateFitness?(this.error=!0,NetworkError.error("calculateFitness() missing on agent.","NEATPopulation.buildAgent"),!1):a}run(){if(!this.error){if(this.pause)this.agents.forEach(a=>a.render());else{this.runTimer(),this.checkDone();for(let a=0;a<this.popSize;a++)this.agents[a].run(),this.TopAgentsView?(this.agents[a].topAgent||this.agents[a].eliteAgent)&&this.agents[a].render():this.agents[a].render()}this.render()}}runTimer(){this.timerEnabled&&(frameCount%60==0&&this.timer--,this.timer||this.reset(),push(),fill(this.styling.fontColour??"#000000"),text(this.timer,width-20,15),pop())}checkDone(){for(let a=0;a<this.popSize;a++)if(!this.agents[a].done)return!1;return this.reset(),!0}evaluate(){let a=-1/0,b=1/0;this.agents.forEach(c=>{c.calculateFitness(),c.fitness>a&&(a=c.fitness,this.topAgent=c,this.topAgent.brain.id="topAgent"),c.fitness<b&&(b=c.fitness)}),this.topFitness=a,this.normaliseFitness(b,a),this.getAverageFitness(),this.fillMatingPool(),this.renderAgentBrain(this.topAgent),this.selection()}selection(){this.agents=this.agents.map((c,a)=>{let b=this.buildAgent(a<this.eliteAgents+1?c.brain.copy():NEATAgent.crossover(this.selectAgent(),this.selectAgent(),this.mutationRate));return a<this.eliteAgents+1&&(0===a?b.topAgent=!0:b.eliteAgent=!0),b}),this.generation++,"undefined"!=typeof completedGeneration&&completedGeneration(this.topAgent)}fillMatingPool(){if(this.matingPool=[],this.agents.sort((a,b)=>b.fitness-a.fitness).forEach((a,c)=>{if(!a.topAgent&&!a.eliteAgent&&a.fitness>=this.averageFitness){let d=100*a.fitness;for(let b=0;b<d;b++)this.matingPool.push(c)}}),0===this.matingPool.length)for(let a=0;a<this.popSize;a++)this.matingPool.push(a)}normaliseFitness(a,b){this.agents.forEach(c=>c.fitness=a===b?c.fitness/b:(c.fitness-a)/(b-a))}selectAgent(){return this.agents[rand(this.matingPool)]}getAverageFitness(){let a=0;this.agents.forEach(b=>a+=b.fitness),this.averageFitness=a/this.agents.length}collectData(a,b){this.datacollection.push({input:a instanceof Array?a:[a],target:b instanceof Array?b:[b]})}setTimer(a){"boolean"==typeof a?(this.timerEnabled=a,this.timerEnabled&&this.setTimer(this.timerCount)):isNumber(a)&&a>0?(this.timerCount=a,this.timer=a,this.timerEnabled=!0,this.rerun()):NetworkError.error("Neither a bool or number provided.")}mutateOutputActivation(b,a){isNumber(a)&&(a>1&&(NetworkError.warn("Percentage is between 0 and 1, setting value to 1","NEATPopulation.mutateOutputActivation"),a=1),a<0&&(NetworkError.warn("Percentage is between 0 and 1, setting value to 0","NEATPopulation.mutateOutputActivation"),a=0)),void 0===a&&(a=!1),this.agents.forEach(c=>{c.brain.nodes.forEach(d=>{d.output&&rand()<(!1!==a?a:c.brain.mutationRates.activationRate)&&d.mutateActivation(b)})})}downloadDataset(a="Dataset"){download(a,JSON.stringify(this.datacollection))}reset(){this.evaluate(),this.timer=this.timerCount}rerun(){this.agents=this.agents.map(a=>{let b=this.buildAgent(a.brain.copy());return a.topAgent?b.topAgent=!0:a.eliteAgents&&(b.eliteAgent=!0),b}),this.timer=this.timerCount}restart(){this.agents=[],this.datacollection=[],this.topFitness=0,this.generateAgentsPool(),this.generation=1,this.rerun();let a=document.getElementById(this.topAgent?.brain.id);a&&a.parentNode.removeChild(a)}togglePause(){this.pause=!this.pause}toggleTopAgentsView(){this.TopAgentsView=!this.TopAgentsView}toggleBrainRender(){if(this.showBrain=!this.showBrain,this.showBrain)this.renderAgentBrain(this.topAgent);else{let a=document.getElementById(this.topAgent.brain.id);a&&a.parentNode.removeChild(a)}}fastForward(c=1){let e=()=>{d=0,this.reset(),clog("Generation",this.generation,`${(performance.now()-i).toFixed(2)}/ms`)};this.rerun(),this.pause=!0;let f=this.generation+c,g=60*this.timerCount,h=performance.now(),d=0,i;for(;this.generation<f;){for(i=performance.now();d<g;){for(let b=0;b<this.popSize;b++)this.agents[b].run();d++}e()}if(1!==c){let a=((performance.now()-h)/1e3).toFixed(2);a=a<60?`${a}/s`:`${(a/60).toFixed(2)}/m`,clog("Fast Forward Completed",a)}this.pause=!1}nextBest(){let b=this.topFitness,a=0;for(;b>=this.topFitness&&a<100;)a++,this.fastForward();b<this.topFitness?clog("Next Top Agent:",a,"Generations later.",`+${this.topFitness-b}`):clog("No New Top Agent:",a,"Generations later")}renderAgentBrain(a,f=500,g=400,d="svgBrainContainer"){if(!this.showBrain)return;if(!(a instanceof NEATGenome)&&!((a=a?.brain)instanceof NEATGenome)){NetworkError("NEATGenome not passed into fender function.");return}let l=document.getElementById(d);if(!l){let b=document.createElement("div");b.id=d,b.style.position="absolute",b.style.top="5px",b.style.right="5px",document.body.prepend(b)}let c=document.getElementById(a.id);c&&c.parentNode.removeChild(c);let h=d3.select("body").append("svg").attr("width",f).attr("height",g).attr("id",a.id),e=d3.layout.force().size([f,g]),m=1/0,n=-1/0,i=a.connections.map(b=>(b.weight>n&&(n=b.weight),b.weight<m&&(m=b.weight),{source:a.getNode(b.fromNode.number),target:a.getNode(b.toNode.number),weight:b.weight,enabled:b.enabled})),j=a.nodes.map(c=>{let b=c.copy();return 0===b.layer?(b.fixed=!0,b.y=g-.2*g,b.x=f/a.inputs*b.number+f/a.inputs/2):b.output&&(b.fixed=!0,b.y=.2*g,b.x=f/a.outputs*(b.number-a.inputs)+f/a.outputs/2),b}),o=(b,a,c)=>`hsl(${((1-(b-a)/(c-a))*120).toString(10)},100%,50%)`;e.nodes(j).links(i).gravity(.001).linkStrength(1).start();let p=h.selectAll(".link").data(i).enter().append("line").attr("class","link").style("stroke-width",a=>a.enabled?abs(a.weight)+1:0).style("stroke",a=>o(a.weight,m,n)).style("opacity",a=>0===a.source.layer&&a.target.output?"0.5":"1"),k=h.selectAll(".node").data(j).enter().append("g").attr("class","node").call(e.drag);k.append("circle").attr("r","5").attr("fill",a=>0==a.layer?"#00f":a.output?"#f00":"#000"),k.append("text").attr("dx",10).attr("dy",4).style("fill",this.styling.fontColour??"#000000").text(a=>a.output?`(${a.activation})`:null),e.on("tick",()=>{p.attr("x1",a=>a.source.x).attr("y1",a=>a.source.y).attr("x2",a=>a.target.x).attr("y2",a=>a.target.y),k.attr("transform",a=>`translate(${a.x},${a.y})`)}),c=document.getElementById(a.id),document.getElementById(d).append(c)}render(){push(),fill(this.styling.fontColour??"#000000"),text(`Generation: ${this.generation}`,10,15),text(`Top Fitness: ${this.topFitness.toFixed(2)}`,100,15),pop()}static help(){console.log("%cNEAT Population Guide","font-size: 2em; font-weight: bold;"),console.log("%cGetting Started","font-size: 1.5em; font-weight: bold;"),console.log("	1: Create an agent that extends the NEATAgent class."),console.log('	2: Give the agent a "calculateFitness()" function.'),console.log('	3: Create a "createNEATGenome()" function to initialise the NEAT Genome.'),console.log("		ex: const createNEATGenome = (id) => new NEATGenome(input, output, id);"),console.log("	4: Create a new population passing in the agent constructor and population size."),console.log('	5: ".run()" your agents and NEATpopulation.'),console.log("\n"),console.log("%csetTimer","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: seconds: int / bool"),console.log("	Description: Set the number of seconds for generations before evaluation."),console.log("	Overload: Boolean sets enables / disabled the timer component of the population."),console.log("\n"),console.log("%ctogglePause","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Un/pause the current generation and timer."),console.log("\n"),console.log("%ctoggleTopAgentsView","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Show/Hide the current generations top /elite agent/s."),console.log("\n"),console.log("%cfastForward","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: targetGeneration: int"),console.log("	Description: Quickly evaluate generations in the background until the target generation."),console.log("\n"),console.log("%cnextBest","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Quickly evaluate generations in the background until the next best agent."),console.log("\n"),console.log("%cmutateOutputActivation","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: activation: string, percentage: float (0 - 1)"),console.log('	Description: Mutate the current populations output activation functions by a rate of "percentage" to the chosen function.'),console.log("\n"),console.log("%creset","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Evaluates the current generation at the time of the function call."),console.log("\n"),console.log("%crerun","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Restarts the current generation."),console.log("\n"),console.log("%crestart","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Reset the current population to generation 0."),console.log("\n"),console.log("%ccollectData","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: input : Array, target: Array"),console.log("	Description: Push the passed inputs and target into an array for a machine learning dataset."),console.log("\n"),console.log("%cdownloadDataset","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Download the current stored dataset."),console.log("\n"),console.log("%ctoggleBrainRender","font-size: 1.5em; font-weight: bold;"),console.log("	Parameters: NA"),console.log("	Description: Show/Hide the rendered top agent model.")}}class NEATAgent{constructor(a){if(a instanceof NEATGenome)this.brain=a;else if("undefined"!=typeof createNEATGenome)this.brain=createNEATGenome(a);else{NetworkError.error("createNEATGenome() needed to create a neural netword for the NEATAgent.","NEATAgent.constructor");return}this.failed=!1,this.success=!1,this.done=!1,this.topAgent=!1,this.eliteAgent=!1,this.fitness=0,this.score=0}static crossover(a,b,d=.1){let c;return(c=a.fitness>b.fitness?a.brain.crossover(b.brain):b.brain.crossover(a.brain)).mutate(d),c}}class QuadPoint{constructor(a){this.item=a,this.x=a.position.x,this.y=a.position.y}}class BoundingBox{constructor(a,b,c,d){this.x=a,this.y=b,this.w=c,this.h=d}contains(a){return a.x>=this.x-this.w&&a.x<this.x+this.w&&a.y>=this.y-this.h&&a.y<this.y+this.h}intersects(a){return!(a.x-a.w>this.x+this.w||a.x+a.w<this.x-this.w||a.y-a.h>this.y+this.h||a.y+a.h<this.y-this.h)}show(){stroke(255),noFill(),strokeWeight(1),rectMode(CENTER)}}class QuadTree{constructor(a,b,c=1){this.boundary=a,this.capacity=b,this.points=[],this.divided=!1,this.nested=c,this.maxNesting=1/0}subdivide(){let c=this.boundary.x,d=this.boundary.y,a=this.boundary.w,b=this.boundary.h,e=new BoundingBox(c+a/2,d-b/2,a/2,b/2);this.northeast=new QuadTree(e,this.capacity,this.nested+1);let f=new BoundingBox(c-a/2,d-b/2,a/2,b/2);this.northwest=new QuadTree(f,this.capacity,this.nested+1);let g=new BoundingBox(c+a/2,d+b/2,a/2,b/2);this.southeast=new QuadTree(g,this.capacity,this.nested+1);let h=new BoundingBox(c-a/2,d+b/2,a/2,b/2);this.southwest=new QuadTree(h,this.capacity,this.nested+1),this.divided=!0}insert(a){if(void 0===a.position)return console.error("Point missing .position"),!1;this.addToTree(new QuadPoint(a))}addToTree(a){return!!this.boundary.contains(a)&&(this.points.length<this.capacity?(this.points.push(a),!0):!!(this.nested>this.maxNesting||(this.divided||this.subdivide(),this.northeast.addToTree(a))||this.northwest.addToTree(a)||this.southeast.addToTree(a)||this.southwest.addToTree(a))||void 0)}query(a){return a instanceof BoundingBox?this.getItemsInArea(a)||[]:(console.error('"BoundingBox" missing'),!1)}getItemsInArea(b,a){if(a||(a=[]),this.boundary.intersects(b)){for(let c=0;c<this.points.length;c++)b.contains(this.points[c])&&a.push(this.points[c].item);return this.divided&&(this.northwest.getItemsInArea(b,a),this.northeast.getItemsInArea(b,a),this.southwest.getItemsInArea(b,a),this.southeast.getItemsInArea(b,a)),a}}getEachItem(a){a||(a=[]);for(let b=0;b<this.points.length;b++)a.push(this.points[b].item);return this.divided&&(this.northwest.getEachItem(a),this.northeast.getEachItem(a),this.southwest.getEachItem(a),this.southeast.getEachItem(a)),a}runEachItem(...a){for(let b=0;b<this.points.length;b++)this.points[b].item.run(...a);this.divided&&(this.northwest.runEachItem(...a),this.northeast.runEachItem(...a),this.southwest.runEachItem(...a),this.southeast.runEachItem(...a))}filterTree(a,b){let c=this.points.filter(c=>c.item[a]!==b);if(this.divided&&(this.northwest.filterTree(a,b),this.northeast.filterTree(a,b),this.southwest.filterTree(a,b),this.southeast.filterTree(a,b)),c.length===this.points.length)return this;this.points=c;let d=this.getEachItem(),e=this.boundary.x,f=this.boundary.y,g=this.boundary.w,h=this.boundary.h,i=new QuadTree(new BoundingBox(e,f,g,h),this.capacity);return d.forEach(a=>i.insert(a)),i}show(){push(),stroke(255),noFill(),strokeWeight(1),rectMode(CENTER),rect(this.boundary.x,this.boundary.y,2*this.boundary.w,2*this.boundary.h),this.divided&&(this.northeast.show(),this.northwest.show(),this.southeast.show(),this.southwest.show()),pop()}}